<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Svatantra-Nagari - Smart City 3D Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Svatantra-Nagari Title */
        .city-title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2.5em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            pointer-events: none;
            z-index: 150;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            pointer-events: all;
            min-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .infrastructure-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            pointer-events: all;
            min-width: 350px;
            max-height: 60vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .traffic-control-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            pointer-events: all;
            min-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bridge-details-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            pointer-events: all;
            min-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .agent-status {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 10px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }

        .agent-status:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .env-status { border-left-color: #4ade80; }
        .infra-status { border-left-color: #3b82f6; }
        .traffic-status { border-left-color: #ef4444; }

        .control-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            font-size: 0.9em;
            width: 100%;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .traffic-light-control {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .light-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }

        .light-red { background-color: #ff0000; }
        .light-yellow { background-color: #ffaa00; }
        .light-green { background-color: #00ff00; }

        .bridge-sensor {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            border-left: 3px solid;
        }

        .sensor-normal { border-left-color: #4ade80; }
        .sensor-warning { border-left-color: #fbbf24; }
        .sensor-critical { border-left-color: #ef4444; }

        .data-value {
            font-weight: bold;
            color: #ffffff;
        }

        .pulsing {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4ade80;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active { background-color: #4ade80; }
        .status-warning { background-color: #fbbf24; }
        .status-critical { background-color: #ef4444; }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <h3>Loading Svatantra-Nagari Smart City...</h3>
            <p>Initializing road networks, traffic systems, and bridge infrastructure...</p>
        </div>

        <div id="ui-overlay">
            <!-- City Title -->
            <div class="city-title">
                ‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞-‡§®‡§ó‡§∞‡•Ä<br>
                <span style="font-size: 0.6em; letter-spacing: 1px;">SVATANTRA-NAGARI</span>
            </div>

          

               

            <!-- Infrastructure Panel -->
            <div class="infrastructure-panel">
                <h3>üåâ Infrastructure Monitoring</h3>
                
                <h4>Main Bridge - Structure Analysis</h4>
                <div id="bridge-sensors">
                    <div class="bridge-sensor sensor-critical">
                        <span>Strain Sensor SG001</span>
                        <span class="data-value" id="sg001-value">285 ¬µŒµ</span>
                    </div>
                    <div class="bridge-sensor sensor-normal">
                        <span>Strain Sensor SG002</span>
                        <span class="data-value" id="sg002-value">180 ¬µŒµ</span>
                    </div>
                    <div class="bridge-sensor sensor-warning">
                        <span>Strain Sensor SG003</span>
                        <span class="data-value" id="sg003-value">240 ¬µŒµ</span>
                    </div>
                    <div class="bridge-sensor sensor-normal">
                        <span>Strain Sensor SG004</span>
                        <span class="data-value" id="sg004-value">165 ¬µŒµ</span>
                    </div>
                </div>

                <h4>Vibration Analysis</h4>
                <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div>Mode 1 Frequency: <span class="data-value">2.43 Hz</span></div>
                    <div>Mode 2 Frequency: <span class="data-value">4.78 Hz</span></div>
                    <div>Damping Ratio: <span class="data-value">2.8%</span></div>
                </div>

                <h4>Load Monitoring</h4>
                <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div>Current Vehicles: <span class="data-value" id="bridge-vehicles">0</span></div>
                    <div>Total Load: <span class="data-value" id="bridge-load">0 kN</span></div>
                    <div>Max Axle Load: <span class="data-value" id="max-axle">0 kN</span></div>
                </div>

                <button class="control-button" onclick="generateMaintenanceReport()">
                    üìã Generate Maintenance Report
                </button>
            </div>

            <!-- Traffic Control Panel -->
            <div class="traffic-control-panel">
                <h3>üö¶ Traffic Signal Control</h3>
                
                <div id="traffic-lights">
                    <div class="traffic-light-control">
                        <div class="light-indicator light-green" id="light-ts001"></div>
                        <span>TS001 - Main St & 1st Ave</span>
                        <button onclick="changeLight('TS001')" style="margin-left: auto; padding: 4px 8px; border: none; background: #333; color: white; border-radius: 4px;">Change</button>
                    </div>
                    <div class="traffic-light-control">
                        <div class="light-indicator light-red" id="light-ts002"></div>
                        <span>TS002 - Highway 101</span>
                        <button onclick="changeLight('TS002')" style="margin-left: auto; padding: 4px 8px; border: none; background: #333; color: white; border-radius: 4px;">Change</button>
                    </div>
                    <div class="traffic-light-control">
                        <div class="light-indicator light-yellow" id="light-ts003"></div>
                        <span>TS003 - Downtown Bridge</span>
                        <button onclick="changeLight('TS003')" style="margin-left: auto; padding: 4px 8px; border: none; background: #333; color: white; border-radius: 4px;">Change</button>
                    </div>
                    <div class="traffic-light-control">
                        <div class="light-indicator light-green" id="light-ts004"></div>
                        <span>TS004 - University Gate</span>
                        <button onclick="changeLight('TS004')" style="margin-left: auto; padding: 4px 8px; border: none; background: #333; color: white; border-radius: 4px;">Change</button>
                    </div>
                </div>

                <h4>Traffic Flow Status</h4>
                <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div>Active Vehicles: <span class="data-value" id="total-vehicles">0</span></div>
                    <div>Average Speed: <span class="data-value" id="avg-speed">0 km/h</span></div>
                    <div>Congestion Level: <span class="data-value" id="congestion-percent">0%</span></div>
                </div>
            </div>

            <!-- Bridge Details Panel -->
            <div class="bridge-details-panel">
                <h3>üîß Bridge Infrastructure Details</h3>
                
                <h4>Structural Components</h4>
                <div style="font-size: 0.9em;">
                    <div style="margin: 8px 0;"><strong>Main Span:</strong> 120m steel truss</div>
                    <div style="margin: 8px 0;"><strong>Supports:</strong> 4 concrete piers</div>
                    <div style="margin: 8px 0;"><strong>Deck:</strong> Reinforced concrete</div>
                    <div style="margin: 8px 0;"><strong>Load Capacity:</strong> 500 kN</div>
                </div>

                <h4>Health Assessment</h4>
                <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div>Overall Health: <span class="data-value" style="color: #fbbf24;">Fair (65%)</span></div>
                    <div>Fatigue Life: <span class="data-value" style="color: #4ade80;">15 years</span></div>
                    <div>Inspection Due: <span class="data-value" style="color: #ef4444;">48 hours</span></div>
                </div>

                <h4>Real-time Alerts</h4>
                <div id="bridge-alerts" style="font-size: 0.85em;">
                    <div style="color: #ef4444; margin: 5px 0;">‚ö†Ô∏è SG001 exceeded threshold</div>
                    <div style="color: #fbbf24; margin: 5px 0;">‚ö†Ô∏è High traffic load detected</div>
                </div>

                <button class="control-button" onclick="startBridgeInspection()">
                    üîç Start Automated Inspection
                </button>
            </div>
        </div>
    </div>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let roadNetwork = {};
        let vehicles = [];
        let trafficLights = {};
        let bridgeComponents = {};
        let infrastructureSensors = {};
        let currentTrafficLightStates = {};
        
        // Traffic simulation variables
        let trafficFlowActive = true;
        let emergencyMode = false;
        let bridgeInspectionMode = false;

        // Initialize the enhanced 3D scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 100, 800);

            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(150, 120, 200);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 20;
            controls.maxDistance = 500;

            // Add event listeners
            window.addEventListener('resize', onWindowResize);

            // Set up enhanced lighting
            setupEnhancedLighting();
            
            // Create enhanced city
            createEnhancedCity();
            
            // Start systems
            startSimulationSystems();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
        }

        function setupEnhancedLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(200, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 1000;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            scene.add(directionalLight);

            // Multiple area lights for realistic lighting
            const lights = [
                { pos: [100, 50, 100], color: 0xffffff, intensity: 0.6 },
                { pos: [-100, 50, 100], color: 0xffffff, intensity: 0.6 },
                { pos: [100, 50, -100], color: 0xffffff, intensity: 0.6 },
                { pos: [-100, 50, -100], color: 0xffffff, intensity: 0.6 }
            ];

            lights.forEach(light => {
                const pointLight = new THREE.PointLight(light.color, light.intensity, 200);
                pointLight.position.set(...light.pos);
                scene.add(pointLight);
            });
        }

        function createEnhancedCity() {
            // Create enhanced ground
            createEnhancedGround();
            
            // Create comprehensive road network
            createComprehensiveRoadNetwork();
            
            // Create detailed bridge infrastructure
            createDetailedBridge();
            
            // Create districts with buildings (positioned to avoid bridge)
            createEnhancedDistricts();
            
            // Create traffic management system
            createTrafficManagementSystem();
            
            // Create environmental systems
            createEnvironmentalSystems();
        }

        function createEnhancedGround() {
            // Main ground plane
            const groundGeometry = new THREE.PlaneGeometry(800, 800);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d3748,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Enhanced grid system
            const gridHelper = new THREE.GridHelper(800, 80, 0x4a5568, 0x2d3748);
            gridHelper.position.y = 0.1;
            scene.add(gridHelper);

            // Add city zones with different textures
            createCityZones();
        }

        function createCityZones() {
            const zones = [
                { center: [0, 50], size: 80, color: 0x4a5568, name: 'downtown' }, // Moved away from bridge
                { center: [-120, 120], size: 60, color: 0x68d391, name: 'residential' },
                { center: [120, 120], size: 60, color: 0x63b3ed, name: 'commercial' },
                { center: [-120, -120], size: 60, color: 0xfbb6ce, name: 'industrial' },
                { center: [120, -120], size: 60, color: 0xfbd38d, name: 'tech_district' }
            ];

            zones.forEach(zone => {
                const zoneGeometry = new THREE.CylinderGeometry(zone.size, zone.size, 1, 16);
                const zoneMaterial = new THREE.MeshLambertMaterial({ 
                    color: zone.color,
                    transparent: true,
                    opacity: 0.2
                });
                const zoneMesh = new THREE.Mesh(zoneGeometry, zoneMaterial);
                zoneMesh.position.set(zone.center[0], 0.5, zone.center[1]);
                zoneMesh.userData = { type: 'zone', name: zone.name };
                scene.add(zoneMesh);
            });
        }

        function createComprehensiveRoadNetwork() {
            // Define comprehensive road network with proper bridge connections
            const roadSegments = [
                // Main arterials connecting to bridge
                { start: [-150, 0], end: [-60, 0], width: 12, type: 'highway', lanes: 4 },
                { start: [60, 0], end: [150, 0], width: 12, type: 'highway', lanes: 4 },
                { start: [0, -300], end: [0, -20], width: 12, type: 'highway', lanes: 4 },
                { start: [0, 20], end: [0, 300], width: 12, type: 'highway', lanes: 4 },
                
                // Bridge deck (elevated)
                { start: [-60, 0], end: [60, 0], width: 10, type: 'bridge_deck', lanes: 3, elevation: 8 },
                
                // Secondary roads
                { start: [-200, -200], end: [200, 200], width: 8, type: 'arterial', lanes: 2 },
                { start: [-200, 200], end: [200, -200], width: 8, type: 'arterial', lanes: 2 },
                
                // Local roads
                { start: [-150, -100], end: [150, -100], width: 6, type: 'local', lanes: 2 },
                { start: [-150, 100], end: [150, 100], width: 6, type: 'local', lanes: 2 },
                { start: [-100, -150], end: [-100, 150], width: 6, type: 'local', lanes: 2 },
                { start: [100, -150], end: [100, 150], width: 6, type: 'local', lanes: 2 }
            ];

            roadSegments.forEach((road, index) => {
                createRoadSegment(road, `road_${index}`);
            });

            // Create intersections
            createIntersections();
        }

        function createRoadSegment(road, roadId) {
            const [startX, startZ] = road.start;
            const [endX, endZ] = road.end;
            const length = Math.sqrt((endX - startX) ** 2 + (endZ - startZ) ** 2);
            const angle = Math.atan2(endZ - startZ, endX - startX);
            const elevation = road.elevation || 0.2;

            // Road surface
            const roadGeometry = new THREE.PlaneGeometry(length, road.width);
            const roadMaterial = new THREE.MeshLambertMaterial({ 
                color: road.type === 'bridge_deck' ? 0x606060 : 0x2d3748,
                transparent: true,
                opacity: 0.9
            });
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.rotation.x = -Math.PI / 2;
            roadMesh.rotation.z = angle;
            roadMesh.position.set((startX + endX) / 2, elevation, (startZ + endZ) / 2);
            roadMesh.receiveShadow = true;
            
            roadMesh.userData = { 
                type: 'road', 
                roadId: roadId,
                roadType: road.type,
                lanes: road.lanes,
                start: road.start,
                end: road.end,
                angle: angle,
                length: length,
                elevation: elevation
            };
            
            scene.add(roadMesh);
            roadNetwork[roadId] = roadMesh;

            // Add lane markings
            createLaneMarkings(road, angle, (startX + endX) / 2, (startZ + endZ) / 2, length, elevation);

            // Add sidewalks for non-bridge roads
            if (road.type !== 'bridge_deck') {
                createSidewalks(road, angle, (startX + endX) / 2, (startZ + endZ) / 2, length);
            }
        }

        function createLaneMarkings(road, angle, centerX, centerZ, length, elevation) {
            const markingWidth = 0.3;
            const markingLength = 2;
            const spacing = 4;

            // Center line
            for (let i = -length/2; i < length/2; i += spacing) {
                const markingGeometry = new THREE.PlaneGeometry(markingLength, markingWidth);
                const markingMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                marking.rotation.x = -Math.PI / 2;
                marking.rotation.z = angle;
                marking.position.set(
                    centerX + Math.cos(angle) * i,
                    elevation + 0.05,
                    centerZ + Math.sin(angle) * i
                );
                scene.add(marking);
            }
        }

        function createSidewalks(road, angle, centerX, centerZ, length) {
            const sidewalkWidth = 2;
            const roadHalfWidth = road.width / 2;

            [-1, 1].forEach(side => {
                const sidewalkGeometry = new THREE.PlaneGeometry(length, sidewalkWidth);
                const sidewalkMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4a5568,
                    transparent: true,
                    opacity: 0.7
                });
                
                const sidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
                sidewalk.rotation.x = -Math.PI / 2;
                sidewalk.rotation.z = angle;
                
                const offsetDistance = roadHalfWidth + sidewalkWidth/2 + 1;
                sidewalk.position.set(
                    centerX + Math.cos(angle + Math.PI/2) * offsetDistance * side,
                    0.15,
                    centerZ + Math.sin(angle + Math.PI/2) * offsetDistance * side
                );
                
                scene.add(sidewalk);
            });
        }

        function createIntersections() {
            const intersections = [
                { pos: [0, 100], size: 15, id: 'TS001', name: 'Main St & 1st Ave' },
                { pos: [100, 100], size: 12, id: 'TS002', name: 'Highway 101' },
                { pos: [-100, 100], size: 12, id: 'TS003', name: 'University District' },
                { pos: [100, -100], size: 10, id: 'TS004', name: 'Tech District Gate' },
                { pos: [-100, -100], size: 10, id: 'TS005', name: 'Industrial Zone' }
            ];

            intersections.forEach(intersection => {
                createIntersection(intersection);
            });
        }

        function createIntersection(intersection) {
            const [x, z] = intersection.pos;
            
            // Intersection base
            const intersectionGeometry = new THREE.PlaneGeometry(intersection.size, intersection.size);
            const intersectionMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d3748,
                transparent: true,
                opacity: 0.95
            });
            
            const intersectionMesh = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
            intersectionMesh.rotation.x = -Math.PI / 2;
            intersectionMesh.position.set(x, 0.3, z);
            intersectionMesh.receiveShadow = true;
            scene.add(intersectionMesh);

            // Traffic light system
            createTrafficLightSystem(intersection);
        }

        function createTrafficLightSystem(intersection) {
            const [x, z] = intersection.pos;
            
            // Initialize traffic light state
            currentTrafficLightStates[intersection.id] = {
                phase: 0, // 0: green, 1: yellow, 2: red
                timer: 0,
                duration: [8000, 2000, 6000] // Green, Yellow, Red durations in ms
            };
            
            // Traffic light poles (4 corners)
            const corners = [
                [x + 8, z + 8],
                [x - 8, z + 8],
                [x - 8, z - 8],
                [x + 8, z - 8]
            ];

            trafficLights[intersection.id] = [];

            corners.forEach((corner, index) => {
                // Pole
                const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 12, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x4a5568 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(corner[0], 6, corner[1]);
                pole.castShadow = true;
                scene.add(pole);

                // Traffic light housing
                const housingGeometry = new THREE.BoxGeometry(1.5, 4, 1);
                const housingMaterial = new THREE.MeshLambertMaterial({ color: 0x2d3748 });
                const housing = new THREE.Mesh(housingGeometry, housingMaterial);
                housing.position.set(corner[0], 10, corner[1]);
                scene.add(housing);

                // Traffic lights (Red, Yellow, Green)
                const lightStates = ['red', 'yellow', 'green'];
                const cornerLights = {};
                
                lightStates.forEach((state, lightIndex) => {
                    const lightGeometry = new THREE.SphereGeometry(0.3);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: state === 'red' ? 0xff0000 : state === 'yellow' ? 0xffaa00 : 0x00ff00,
                        transparent: true,
                        opacity: lightIndex === 2 ? 1.0 : 0.3 // Green light on by default
                    });
                    
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(
                        corner[0],
                        10.5 - lightIndex * 0.8,
                        corner[1]
                    );
                    
                    scene.add(light);
                    cornerLights[state] = light;
                });
                
                trafficLights[intersection.id][index] = cornerLights;
            });
        }

        function createDetailedBridge() {
            const bridgeSpan = 120;
            const bridgeWidth = 12;
            const bridgeHeight = 3;
            
            // Main bridge deck - positioned to clear buildings
            const deckGeometry = new THREE.BoxGeometry(bridgeSpan, bridgeHeight, bridgeWidth);
            const deckMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8c8c8c,
                roughness: 0.8
            });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.set(0, 8, 0); // Bridge at y=8
            deck.castShadow = true;
            deck.receiveShadow = true;
            deck.userData = { type: 'bridge_deck', id: 'main_bridge' };
            scene.add(deck);
            bridgeComponents.deck = deck;

            // Bridge supports/piers
            createBridgeSupports();
            
            // Bridge trusses
            createBridgeTrusses();
            
            // Infrastructure sensors
            createInfrastructureSensors();
            
            // Bridge safety barriers
            createBridgeBarriers();
        }

        function createBridgeSupports() {
            const supportPositions = [-45, -15, 15, 45];
            
            supportPositions.forEach((xPos, index) => {
                // Main support pier
                const pierGeometry = new THREE.CylinderGeometry(2, 3, 20, 12);
                const pierMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x6b7280,
                    roughness: 0.9
                });
                const pier = new THREE.Mesh(pierGeometry, pierMaterial);
                pier.position.set(xPos, 5, 0);
                pier.castShadow = true;
                pier.userData = { 
                    type: 'bridge_support', 
                    id: `support_${index + 1}`,
                    health: Math.random() > 0.8 ? 'warning' : 'good'
                };
                scene.add(pier);
                bridgeComponents[`support_${index + 1}`] = pier;

                // Foundation
                const foundationGeometry = new THREE.CylinderGeometry(4, 5, 3, 12);
                const foundation = new THREE.Mesh(foundationGeometry, pierMaterial);
                foundation.position.set(xPos, -1, 0);
                scene.add(foundation);
            });
        }

        function createBridgeTrusses() {
            // Create truss structure along the bridge
            for (let i = -50; i <= 50; i += 10) {
                // Vertical truss members
                const verticalGeometry = new THREE.BoxGeometry(0.5, 6, 0.5);
                const trussMaterial = new THREE.MeshLambertMaterial({ color: 0x7c7c7c });
                
                [-5, 5].forEach(zOffset => {
                    const vertical = new THREE.Mesh(verticalGeometry, trussMaterial);
                    vertical.position.set(i, 12, zOffset);
                    vertical.castShadow = true;
                    scene.add(vertical);
                });

                // Diagonal truss members
                if (i < 50) {
                    const diagonalGeometry = new THREE.BoxGeometry(0.3, 7, 0.3);
                    [-5, 5].forEach(zOffset => {
                        const diagonal = new THREE.Mesh(diagonalGeometry, trussMaterial);
                        diagonal.position.set(i + 5, 12, zOffset);
                        diagonal.rotation.z = Math.PI / 6;
                        scene.add(diagonal);
                    });
                }
            }

            // Top chord
            const chordGeometry = new THREE.BoxGeometry(120, 0.8, 0.8);
            [-5, 5].forEach(zOffset => {
                const chord = new THREE.Mesh(chordGeometry, new THREE.MeshLambertMaterial({ color: 0x7c7c7c }));
                chord.position.set(0, 15, zOffset);
                chord.castShadow = true;
                scene.add(chord);
            });
        }

        function createInfrastructureSensors() {
            const sensorPositions = [
                { x: 0, y: 11, z: 0, id: 'SG001', type: 'strain', status: 'critical' },
                { x: -30, y: 11, z: 0, id: 'SG002', type: 'strain', status: 'normal' },
                { x: 30, y: 11, z: 0, id: 'SG003', type: 'strain', status: 'warning' },
                { x: 0, y: 11, z: 5, id: 'SG004', type: 'strain', status: 'normal' }
            ];

            sensorPositions.forEach(sensor => {
                const sensorGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const sensorColor = sensor.status === 'critical' ? 0xff0000 : 
                                  sensor.status === 'warning' ? 0xffaa00 : 0x00ff00;
                
                const sensorMaterial = new THREE.MeshLambertMaterial({ 
                    color: sensorColor,
                    emissive: sensorColor,
                    emissiveIntensity: 0.3
                });
                
                const sensorMesh = new THREE.Mesh(sensorGeometry, sensorMaterial);
                sensorMesh.position.set(sensor.x, sensor.y, sensor.z);
                sensorMesh.userData = {
                    type: 'infrastructure_sensor',
                    sensorType: sensor.type,
                    id: sensor.id,
                    status: sensor.status,
                    value: Math.floor(Math.random() * 300 + 50)
                };
                
                scene.add(sensorMesh);
                infrastructureSensors[sensor.id] = sensorMesh;

                // Add pulsing effect for critical sensors
                if (sensor.status === 'critical') {
                    const pulseLight = new THREE.PointLight(0xff0000, 2, 10);
                    pulseLight.position.set(sensor.x, sensor.y + 2, sensor.z);
                    scene.add(pulseLight);
                }
            });
        }

        function createBridgeBarriers() {
            // Safety barriers along bridge edges
            [-8, 8].forEach(zOffset => {
                for (let x = -55; x <= 55; x += 5) {
                    const barrierGeometry = new THREE.BoxGeometry(4, 1.2, 0.2);
                    const barrierMaterial = new THREE.MeshLambertMaterial({ color: 0x9ca3af });
                    const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                    barrier.position.set(x, 10.2, zOffset);
                    barrier.castShadow = true;
                    scene.add(barrier);
                }
            });
        }

        function createEnhancedDistricts() {
            const districts = [
                { name: 'Downtown', center: [0, 80], color: 0xff6b6b, buildings: 15 }, // Moved away from bridge
                { name: 'Northside', center: [-120, 120], color: 0x4ecdc4, buildings: 12 },
                { name: 'Eastport', center: [120, 120], color: 0x45b7d1, buildings: 10 },
                { name: 'Westview', center: [-120, -120], color: 0x96ceb4, buildings: 8 },
                { name: 'Tech District', center: [120, -120], color: 0xfeca57, buildings: 10 }
            ];

            districts.forEach(district => {
                createDistrictBuildings(district);
            });
        }

        function createDistrictBuildings(district) {
            const [centerX, centerZ] = district.center;
            
            for (let i = 0; i < district.buildings; i++) {
                const angle = (i / district.buildings) * Math.PI * 2;
                const radius = 20 + Math.random() * 40;
                const x = centerX + Math.cos(angle) * radius;
                const z = centerZ + Math.sin(angle) * radius;
                
                // Ensure buildings don't interfere with bridge (y=0 bridge area)
                if (Math.abs(x) < 70 && Math.abs(z) < 15) {
                    continue; // Skip buildings that would interfere with bridge
                }
                
                const height = 10 + Math.random() * (district.name === 'Downtown' ? 40 : 25);
                const width = 5 + Math.random() * 8;
                const depth = 5 + Math.random() * 8;

                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color(district.color).multiplyScalar(0.6 + Math.random() * 0.4)
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(x, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                building.userData = { 
                    type: 'building', 
                    district: district.name,
                    height: height
                };
                scene.add(building);

                // Add building lights
                createBuildingLights(building, x, height, z);
            }
        }

        function createBuildingLights(building, x, height, z) {
            const lightCount = Math.floor(height / 5);
            for (let i = 0; i < lightCount; i++) {
                if (Math.random() > 0.4) { // 60% chance of lights being on
                    const lightY = 3 + i * 5;
                    const lightGeometry = new THREE.SphereGeometry(0.2);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        emissive: 0xffffff,
                        emissiveIntensity: 0.8
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(
                        x + (Math.random() - 0.5) * 3,
                        lightY,
                        z + (Math.random() - 0.5) * 3
                    );
                    scene.add(light);
                }
            }
        }

        function createTrafficManagementSystem() {
            // Create vehicles that follow roads and traffic signals
            createTrafficVehicles();
            
            // Start traffic simulation
            startTrafficSimulation();
        }

        function createTrafficVehicles() {
            const vehicleTypes = [
                { geometry: new THREE.BoxGeometry(2, 1, 4), color: 0xff6b6b, type: 'car' },
                { geometry: new THREE.BoxGeometry(2.5, 2, 8), color: 0x4ecdc4, type: 'truck' },
                { geometry: new THREE.BoxGeometry(1.8, 1, 3.5), color: 0x45b7d1, type: 'small_car' },
                { geometry: new THREE.BoxGeometry(3, 2.5, 12), color: 0x96ceb4, type: 'bus' }
            ];

            // Create vehicles on roads
            Object.keys(roadNetwork).forEach(roadId => {
                const road = roadNetwork[roadId];
                const roadData = road.userData;
                
                const vehicleCount = Math.floor(Math.random() * 6) + 2;
                
                for (let i = 0; i < vehicleCount; i++) {
                    const vehicleType = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
                    const vehicle = new THREE.Mesh(vehicleType.geometry, 
                        new THREE.MeshLambertMaterial({ color: vehicleType.color }));
                    
                    // Position vehicle along road
                    const progress = i / vehicleCount;
                    const roadAngle = roadData.angle;
                    const roadLength = roadData.length;
                    
                    const x = roadData.start[0] + (roadData.end[0] - roadData.start[0]) * progress;
                    const z = roadData.start[1] + (roadData.end[1] - roadData.start[1]) * progress;
                    const y = roadData.elevation + 1.5;
                    
                    vehicle.position.set(x, y, z);
                    vehicle.rotation.y = roadAngle;
                    vehicle.castShadow = true;
                    
                    vehicle.userData = {
                        type: 'vehicle',
                        vehicleType: vehicleType.type,
                        roadId: roadId,
                        baseSpeed: 0.3 + Math.random() * 0.2,
                        currentSpeed: 0,
                        progress: progress,
                        direction: 1,
                        id: `vehicle_${vehicles.length}`,
                        atIntersection: false,
                        waitingAtLight: false
                    };
                    
                    scene.add(vehicle);
                    vehicles.push(vehicle);
                }
            });
        }

        function createEnvironmentalSystems() {
            // Air quality monitoring stations
            const monitoringStations = [
                { pos: [-80, -80], name: 'Industrial Monitor' },
                { pos: [80, 80], name: 'Residential Monitor' },
                { pos: [0, 80], name: 'Commercial Monitor' },
                { pos: [-80, 80], name: 'University Monitor' },
                { pos: [80, -80], name: 'Tech District Monitor' }
            ];

            monitoringStations.forEach(station => {
                const [x, z] = station.pos;
                
                const stationGeometry = new THREE.ConeGeometry(1.5, 6, 8);
                const stationMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4ade80,
                    emissive: 0x004400,
                    emissiveIntensity: 0.3
                });
                
                const stationMesh = new THREE.Mesh(stationGeometry, stationMaterial);
                stationMesh.position.set(x, 5, z);
                stationMesh.userData = { 
                    type: 'environmental_station',
                    name: station.name
                };
                scene.add(stationMesh);
            });

            // Energy grid (simplified)
            createEnergyGrid();
        }

        function createEnergyGrid() {
            // Solar farm
            for (let i = 0; i < 20; i++) {
                const x = -150 + (i % 5) * 12;
                const z = -150 + Math.floor(i / 5) * 10;
                
                const panelGeometry = new THREE.BoxGeometry(8, 0.3, 5);
                const panelMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1a365d,
                    emissive: 0x4299e1,
                    emissiveIntensity: 0.2
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(x, 3, z);
                panel.rotation.x = -Math.PI / 6;
                scene.add(panel);
            }

            // Wind turbines
            for (let i = 0; i < 8; i++) {
                const x = 150 + (i % 4) * 20;
                const z = 150 + Math.floor(i / 4) * 20;
                
                // Turbine tower
                const towerGeometry = new THREE.CylinderGeometry(0.8, 1.2, 35, 8);
                const towerMaterial = new THREE.MeshLambertMaterial({ color: 0xf7fafc });
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.set(x, 17.5, z);
                scene.add(tower);

                // Turbine blades (simplified)
                const bladeGroup = new THREE.Group();
                for (let j = 0; j < 3; j++) {
                    const bladeGeometry = new THREE.BoxGeometry(0.3, 12, 0.8);
                    const blade = new THREE.Mesh(bladeGeometry, towerMaterial);
                    blade.position.y = 6;
                    blade.rotation.z = (j * Math.PI * 2) / 3;
                    bladeGroup.add(blade);
                }
                bladeGroup.position.set(x, 35, z);
                bladeGroup.userData = { type: 'wind_turbine', spinning: true };
                scene.add(bladeGroup);
            }
        }

        function startSimulationSystems() {
            // Start traffic simulation
            startTrafficSimulation();
            
            // Start infrastructure monitoring
            startInfrastructureMonitoring();
            
            // Start environmental monitoring
            startEnvironmentalMonitoring();
            
            // Start UI updates
            startUIUpdates();
        }

        function startTrafficSimulation() {
            setInterval(() => {
                if (trafficFlowActive) {
                    updateTrafficLights();
                    updateTrafficFlow();
                }
            }, 100); // Update every 100ms for smooth movement
        }

        function updateTrafficLights() {
            const currentTime = Date.now();
            
            Object.keys(currentTrafficLightStates).forEach(intersectionId => {
                const state = currentTrafficLightStates[intersectionId];
                const elapsed = currentTime - state.timer;
                
                // Check if it's time to change phase
                if (elapsed >= state.duration[state.phase]) {
                    state.phase = (state.phase + 1) % 3;
                    state.timer = currentTime;
                    
                    // Update visual lights
                    const intersection = trafficLights[intersectionId];
                    if (intersection) {
                        intersection.forEach(corner => {
                            if (corner) {
                                // Reset all lights
                                corner.red.material.opacity = 0.3;
                                corner.yellow.material.opacity = 0.3;
                                corner.green.material.opacity = 0.3;
                                
                                // Activate current light
                                switch(state.phase) {
                                    case 0: // Green
                                        corner.green.material.opacity = 1.0;
                                        break;
                                    case 1: // Yellow
                                        corner.yellow.material.opacity = 1.0;
                                        break;
                                    case 2: // Red
                                        corner.red.material.opacity = 1.0;
                                        break;
                                }
                            }
                        });
                    }
                }
            });
        }

        function updateTrafficFlow() {
            vehicles.forEach(vehicle => {
                const userData = vehicle.userData;
                const road = roadNetwork[userData.roadId];
                
                if (!road) return;
                
                const roadData = road.userData;
                
                // Check traffic light status for vehicles near intersections
                let canMove = true;
                const nearestIntersection = findNearestIntersection(vehicle.position);
                
                if (nearestIntersection && getDistanceToIntersection(vehicle.position, nearestIntersection) < 15) {
                    const lightState = currentTrafficLightStates[nearestIntersection.id];
                    if (lightState && lightState.phase !== 0) { // Not green
                        canMove = false;
                        userData.waitingAtLight = true;
                    } else {
                        userData.waitingAtLight = false;
                    }
                } else {
                    userData.waitingAtLight = false;
                }
                
                // Set current speed based on conditions
                if (canMove && !emergencyMode) {
                    userData.currentSpeed = userData.baseSpeed;
                } else {
                    userData.currentSpeed = 0;
                }
                
                // Update progress along road
                userData.progress += userData.currentSpeed * 0.01;
                
                // Reset if vehicle reaches end of road
                if (userData.progress > 1) {
                    userData.progress = 0;
                    
                    // Find connected road or loop back
                    const connectedRoad = findConnectedRoad(roadData);
                    if (connectedRoad) {
                        userData.roadId = connectedRoad;
                    }
                }
                
                // Calculate new position
                const startX = roadData.start[0];
                const startZ = roadData.start[1];
                const endX = roadData.end[0];
                const endZ = roadData.end[1];
                
                const x = startX + (endX - startX) * userData.progress;
                const z = startZ + (endZ - startZ) * userData.progress;
                const y = roadData.elevation + 1.5;
                
                vehicle.position.set(x, y, z);
                vehicle.rotation.y = roadData.angle;
                
                // Update bridge load if vehicle is on bridge
                if (roadData.roadType === 'bridge_deck') {
                    updateBridgeLoad();
                }
            });
        }

        function findNearestIntersection(position) {
            const intersections = [
                { id: 'TS001', pos: [0, 100] },
                { id: 'TS002', pos: [100, 100] },
                { id: 'TS003', pos: [-100, 100] },
                { id: 'TS004', pos: [100, -100] },
                { id: 'TS005', pos: [-100, -100] }
            ];
            
            let nearest = null;
            let minDistance = Infinity;
            
            intersections.forEach(intersection => {
                const distance = Math.sqrt(
                    Math.pow(position.x - intersection.pos[0], 2) +
                    Math.pow(position.z - intersection.pos[1], 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = intersection;
                }
            });
            
            return minDistance < 20 ? nearest : null;
        }

        function getDistanceToIntersection(position, intersection) {
            return Math.sqrt(
                Math.pow(position.x - intersection.pos[0], 2) +
                Math.pow(position.z - intersection.pos[1], 2)
            );
        }

        function findConnectedRoad(currentRoadData) {
            // Simple logic to find connecting roads
            const roadIds = Object.keys(roadNetwork);
            const availableRoads = roadIds.filter(id => id !== currentRoadData.roadId);
            return availableRoads[Math.floor(Math.random() * availableRoads.length)];
        }

        function updateBridgeLoad() {
            // Count vehicles on bridge
            const bridgeVehicles = vehicles.filter(v => {
                const road = roadNetwork[v.userData.roadId];
                return road && road.userData.roadType === 'bridge_deck';
            });
            
            // Update UI
            document.getElementById('bridge-vehicles').textContent = bridgeVehicles.length;
            
            // Calculate total load (simplified)
            const totalLoad = bridgeVehicles.length * 25; // Average 25 kN per vehicle
            document.getElementById('bridge-load').textContent = `${totalLoad} kN`;
            
            // Update max axle load
            const maxAxle = bridgeVehicles.length > 0 ? Math.max(20, totalLoad / bridgeVehicles.length) : 0;
            document.getElementById('max-axle').textContent = `${Math.round(maxAxle)} kN`;
        }

        function startInfrastructureMonitoring() {
            setInterval(() => {
                updateInfrastructureSensors();
                updateBridgeAnalysis();
            }, 2000); // Update every 2 seconds
        }

        function updateInfrastructureSensors() {
            // Update strain sensors with realistic variations
            Object.keys(infrastructureSensors).forEach(sensorId => {
                const sensor = infrastructureSensors[sensorId];
                const sensorData = sensor.userData;
                
                // Simulate sensor readings with some variation
                let baseValue = sensorData.value;
                const variation = (Math.random() - 0.5) * 10;
                const newValue = Math.max(50, baseValue + variation);
                
                // Update sensor status based on value
                let newStatus = 'normal';
                if (newValue > 250) {
                    newStatus = 'critical';
                } else if (newValue > 200) {
                    newStatus = 'warning';
                }
                
                // Update sensor appearance
                const color = newStatus === 'critical' ? 0xff0000 : 
                             newStatus === 'warning' ? 0xffaa00 : 0x00ff00;
                
                sensor.material.color.setHex(color);
                sensor.material.emissive.setHex(color);
                sensor.userData.value = newValue;
                sensor.userData.status = newStatus;
                
                // Update UI
                const displayElement = document.getElementById(`${sensorId.toLowerCase()}-value`);
                if (displayElement) {
                    displayElement.textContent = `${Math.round(newValue)} ¬µŒµ`;
                }
            });
        }

        function updateBridgeAnalysis() {
            // Update bridge health assessment
            const criticalSensors = Object.values(infrastructureSensors).filter(
                sensor => sensor.userData.status === 'critical'
            ).length;
            
            const warningSensors = Object.values(infrastructureSensors).filter(
                sensor => sensor.userData.status === 'warning'
            ).length;
            
            let healthStatus = 'Good';
            let healthColor = '#4ade80';
            
            if (criticalSensors > 0) {
                healthStatus = 'Critical';
                healthColor = '#ef4444';
            } else if (warningSensors > 1) {
                healthStatus = 'Fair';
                healthColor = '#fbbf24';
            }
            
            document.getElementById('bridge-health').textContent = healthStatus;
            document.getElementById('bridge-health').style.color = healthColor;
        }

        function startEnvironmentalMonitoring() {
            setInterval(() => {
                updateEnvironmentalData();
            }, 5000); // Update every 5 seconds
        }

        function updateEnvironmentalData() {
            // Simulate environmental data updates
            const airQualityIndex = Math.floor(Math.random() * 100);
            let airQualityStatus = 'Good';
            let airQualityColor = '#4ade80';
            
            if (airQualityIndex > 80) {
                airQualityStatus = 'Poor';
                airQualityColor = '#ef4444';
            } else if (airQualityIndex > 60) {
                airQualityStatus = 'Moderate';
                airQualityColor = '#fbbf24';
            }
            
            document.getElementById('air-quality').textContent = airQualityStatus;
            document.getElementById('air-quality').style.color = airQualityColor;
        }

        function startUIUpdates() {
            setInterval(() => {
                updateTrafficMetrics();
            }, 3000); // Update every 3 seconds
        }

        function updateTrafficMetrics() {
            // Calculate traffic metrics
            const totalVehicles = vehicles.length;
            const movingVehicles = vehicles.filter(v => v.userData.currentSpeed > 0);
            const averageSpeed = totalVehicles > 0 ? 
                vehicles.reduce((sum, v) => sum + v.userData.currentSpeed, 0) / totalVehicles * 100 : 0;
            const waitingVehicles = vehicles.filter(v => v.userData.waitingAtLight).length;
            const congestionLevel = Math.max(0, Math.min(100, (waitingVehicles / totalVehicles) * 100));
            
            document.getElementById('total-vehicles').textContent = totalVehicles;
            document.getElementById('avg-speed').textContent = `${Math.round(averageSpeed)} km/h`;
            document.getElementById('congestion-percent').textContent = `${Math.round(congestionLevel)}%`;
            document.getElementById('congestion-level').textContent = 
                congestionLevel > 80 ? 'Critical' : congestionLevel > 60 ? 'High' : 'Moderate';
        }

        // Control functions
        function focusOnAgent(agentType) {
            // Focus camera on agent-specific areas
            switch(agentType) {
                case 'environmental':
                    camera.position.set(-100, 80, 100);
                    controls.target.set(-100, 0, 0);
                    break;
                case 'infrastructure':
                    camera.position.set(50, 60, 80);
                    controls.target.set(0, 8, 0); // Focus on bridge
                    break;
                case 'traffic':
                    camera.position.set(0, 80, 150);
                    controls.target.set(0, 0, 0); // Focus on main intersection
                    break;
            }
            controls.update();
        }

        function toggleTrafficFlow() {
            trafficFlowActive = !trafficFlowActive;
            console.log(`Traffic flow ${trafficFlowActive ? 'enabled' : 'disabled'}`);
        }

        function simulateEmergency() {
            emergencyMode = !emergencyMode;
            console.log(`Emergency mode ${emergencyMode ? 'activated' : 'deactivated'}`);
            
            if (emergencyMode) {
                // Change all lights to red
                Object.keys(trafficLights).forEach(intersectionId => {
                    const intersection = trafficLights[intersectionId];
                    intersection.forEach(corner => {
                        if (corner) {
                            corner.red.material.opacity = 1.0;
                            corner.yellow.material.opacity = 0.3;
                            corner.green.material.opacity = 0.3;
                        }
                    });
                    
                    // Set traffic light state to red
                    currentTrafficLightStates[intersectionId].phase = 2;
                });
            }
        }

        function optimizeTraffic() {
            // Simulate traffic optimization
            vehicles.forEach(vehicle => {
                vehicle.userData.baseSpeed = Math.min(vehicle.userData.baseSpeed * 1.2, 0.8);
            });
            console.log('Traffic optimization applied');
        }

        function inspectBridge() {
            bridgeInspectionMode = !bridgeInspectionMode;
            console.log(`Bridge inspection mode ${bridgeInspectionMode ? 'started' : 'stopped'}`);
            
            // Highlight bridge components during inspection
            if (bridgeInspectionMode) {
                Object.values(infrastructureSensors).forEach(sensor => {
                    sensor.scale.setScalar(1.5);
                });
            } else {
                Object.values(infrastructureSensors).forEach(sensor => {
                    sensor.scale.setScalar(1.0);
                });
            }
        }

        function changeLight(intersectionId) {
            // Manually change traffic light
            const state = currentTrafficLightStates[intersectionId];
            if (state) {
                state.phase = (state.phase + 1) % 3;
                state.timer = Date.now();
                
                // Update visual representation
                updateTrafficLights();
                
                // Update UI indicator
                const lightElement = document.getElementById(`light-${intersectionId.toLowerCase()}`);
                if (lightElement) {
                    const classes = ['light-green', 'light-yellow', 'light-red'];
                    lightElement.className = `light-indicator ${classes[state.phase]}`;
                }
            }
            
            console.log(`Changed light for ${intersectionId} to phase ${state ? state.phase : 'unknown'}`);
        }

        function generateMaintenanceReport() {
            console.log('Generating maintenance report...');
            alert('Maintenance Report Generated\n\n' +
                  '‚Ä¢ SG001: Requires immediate attention\n' +
                  '‚Ä¢ SG003: Schedule inspection within 1 week\n' +
                  '‚Ä¢ Overall bridge health: Fair\n' +
                  '‚Ä¢ Recommended actions: Replace strain sensor SG001');
        }

        function startBridgeInspection() {
            console.log('Starting automated bridge inspection...');
            alert('Automated Bridge Inspection Started\n\n' +
                  '‚Ä¢ Deploying sensor drones\n' +
                  '‚Ä¢ Scanning structural integrity\n' +
                  '‚Ä¢ Estimating completion: 2 hours\n' +
                  '‚Ä¢ Report will be generated automatically');
        }

        // Event handlers
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            // Animate wind turbines
            scene.traverse(obj => {
                if (obj.userData.type === 'wind_turbine' && obj.userData.spinning) {
                    obj.rotation.z += 0.02;
                }
            });
            
            // Animate sensor pulsing effects
            const time = Date.now() * 0.005;
            Object.values(infrastructureSensors).forEach(sensor => {
                if (sensor.userData.status === 'critical') {
                    sensor.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
                }
            });
            
            renderer.render(scene, camera);
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
